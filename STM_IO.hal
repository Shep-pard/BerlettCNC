
#First load the Python user module
loadusr -Wn STM_IO /home/berlett/linuxcnc/configs/my_LinuxCNC_machine/STM_IO

#Second 'unlinkp' our pins to make them available for use.
# Then use 'net' to recreate/hook into them.

#net 


#net my-jogspeed halui.axis.jog-speed <= arduino.speed
#net my-jogxminus halui.axis.x.minus <= arduino.x-minus
##net my-jogxplus halui.axis.x.plus <= arduino.x-plus
#net my-jogyminus halui.axis.y.minus <= arduino.y-minus
#net my-jogyplus halui.axis.y.plus <= arduino.y-plus

# Spindle power
#unlinkp spindle.0.on
#net spindle-On arduino.spindleEnable <= spindle.0.on

# Stop
#unlinkp iocontrol.0.user-enable-out
#net estop-out arduino.stop

#unlinkp joint.0.motor-pos-cmd
#net xpos-cmd joint.0.motor-pos-cmd => arduino.axis0-cmd

#unlinkp joint.1.motor-pos-cmd
#net ypos-cmd joint.1.motor-pos-cmd => arduino.axis1-cmd

#unlinkp joint.2.motor-pos-cmd
#net zpos-cmd joint.2.motor-pos-cmd => arduino.axis2-cmd


# create nets for all Buttons
#net key-01     <= STM_IO.IN.36 
#net key-001    <= STM_IO.IN.33 
#net key-0001   <= STM_IO.IN.35 
#net key-A-     <= STM_IO.IN.39 
#net key-A+     <= STM_IO.IN.42 
#net key-X-     <= STM_IO.IN.10
#net key-X+     <= STM_IO.IN.38 
#net key-Y-     <= STM_IO.IN.16 
#net key-Y+     <= STM_IO.IN.14 
#net key-Z-     <= STM_IO.IN.12 
#net key-Z+     <= STM_IO.IN.43 
#net key-JogLck <= STM_IO.IN.34 
#net key-LockX  <= STM_IO.IN.24 
#net key-LockY  <= STM_IO.IN.40 
#net key-LockZ  <= STM_IO.IN.11
#net key-LLkX   <= STM_IO.IN.31
#net key-RLkX   <= STM_IO.IN.25 
##net key-SpdlL  <= STM_IO.IN.23
#net key-SpdlR  <= STM_IO.IN.15 
#net key-TlChng <= STM_IO.IN.46 
#net key-Flood  <= STM_IO.IN.41
#net key-MMS    <= STM_IO.IN.30
#net key-Spare1 <= STM_IO.IN.44 
#net key-Spare2 <= STM_IO.IN.47 
#net key-Spare3 <= STM_IO.IN.27 
#net key-Spare4 <= STM_IO.IN.28
#net key-Spare5 <= STM_IO.IN.18 
#net key-Spare6 <= STM_IO.IN.21 
#net key-Spare7 <= STM_IO.IN.19 
#
# create nets for all LEDs

#net led-01      => STM_IO.OUT.39
#net led-001     => STM_IO.OUT.12
#net led-0001    => STM_IO.OUT.38
#net led-A-      => STM_IO.OUT.09
#net led-A+      => STM_IO.OUT.05
#net led-X-      => STM_IO.OUT.24
#net led-X+      => STM_IO.OUT.26
#net led-Y-      => STM_IO.OUT.42
#net led-Y+      => STM_IO.OUT.02
#net led-Z-      => STM_IO.OUT.07
#net led-Z+      => STM_IO.OUT.33
#net led-JogLck  => 
#net led-LockX   => STM_IO.OUT.22
#net led-LockY   => STM_IO.OUT.25
#net led-LockZ   => STM_IO.OUT.35
#net led-LLkX    => STM_IO.OUT.21
#net led-RLkX    => STM_IO.OUT.20
#net led-SpdlL   => STM_IO.OUT.06
#net led-SpdlR   => STM_IO.OUT.18
#net led-TlChng  => STM_IO.OUT.15
#net led-Flood   => STM_IO.OUT.08
#net led-MMS     => STM_IO.OUT.14
#net led-Spare1  => STM_IO.OUT.04
#net led-Spare2  => STM_IO.OUT.11
#net led-Spare3  => STM_IO.OUT.40
#net led-Spare4  => STM_IO.OUT.23
#net led-Spare5  => STM_IO.OUT.19
#net led-Spare6  => STM_IO.OUT.10
#net led-Spare7  => STM_IO.OUT.45




# setup the axis scale 




loadrt or2 names=rst-01,rst-001,rst-0001,STM_IO.led-start,STM_IO.led-stop

addf frtpnl.sel-X   servo-thread
addf frtpnl.sel-Y   servo-thread
addf frtpnl.sel-Z   servo-thread
addf rst-01   servo-thread
addf rst-001  servo-thread
addf rst-0001 servo-thread

loadrt mux8 names=frtpnl.step-choice
addf frtpnl.step-choice servo-thread


loadrt toggleRst names=key-01,key-001,key-0001
addf key-01   servo-thread
addf key-001  servo-thread
addf key-0001 servo-thread

# connect the pysical pins to the toogle input as well as the reset or2 inputs

net key-01.key     <= STM_IO.IN.36 => key-01.in   => rst-001.in0  => rst-0001.in0
net key-001.key    <= STM_IO.IN.33 => key-001.in  => rst-01.in0   => rst-0001.in1
net key-0001.key   <= STM_IO.IN.35 => key-0001.in => rst-01.in1   => rst-001.in1

#connect the toggle reset input to the or2 reset outputs
net rst-01         <=  key-01.rst   => rst-01.out 
net rst-001        <=  key-001.rst  => rst-001.out
net rst-0001       <=  key-0001.rst => rst-0001.out

net led-0001.out  => frtpnl.step-choice.sel0
net led-001.out   => frtpnl.step-choice.sel1
net led-01.out    => frtpnl.step-choice.sel2

setp frtpnl.step-choice.in0 0
setp frtpnl.step-choice.in1 0.001
setp frtpnl.step-choice.in2 0.01
setp frtpnl.step-choice.in4 0.1

net step-choice <= frtpnl.step-choice.out
net step-choice => axis.x.jog-scale
net step-choice => axis.y.jog-scale
net step-choice => axis.z.jog-scale

# connect leds to buttons
#net led-01     <= key-01.out
#net led-01     => STM_IO.OUT.39
#net led-001    <= key-001.out
#net led-001    => STM_IO.OUT.12
#net led-0001   <= key-0001.out
#net led-0001   => STM_IO.OUT.38

net key-01     <= key-01.out
net key-01     => STM_IO.OUT.39
net key-001    <= key-001.out
net key-001    => STM_IO.OUT.12
net key-0001   <= key-0001.out
net key-0001   => STM_IO.OUT.38




# Jog command setup

loadrt  jogCntrl
addf    jogCntrl        servo-thread

loadrt  debounce cfg=8
setp    debounce.0.delay 20
addf    debounce.0      servo-thread




net jog.raw.key-x-pos       <= STM_IO.IN.38     => debounce.0.0.in
net jog.raw.key-x-neg       <= STM_IO.IN.10     => debounce.0.1.in
net jog.raw.key-y-pos       <= STM_IO.IN.14     => debounce.0.2.in
net jog.raw.key-y-neg       <= STM_IO.IN.16     => debounce.0.3.in
net jog.raw.key-z-pos       <= STM_IO.IN.43     => debounce.0.4.in
net jog.raw.key-z-neg       <= STM_IO.IN.12     => debounce.0.5.in
net jog.raw.key-a-pos       <= STM_IO.IN.42     => debounce.0.6.in
net jog.raw.key-a-neg       <= STM_IO.IN.39     => debounce.0.7.in


net jog.deb.key-x-pos       <= debounce.0.0.out => jogCntrl.keys.xpos
net jog.deb.key-x-neg       <= debounce.0.1.out => jogCntrl.keys.xneg
net jog.deb.key-y-pos       <= debounce.0.2.out => jogCntrl.keys.ypos
net jog.deb.key-y-neg       <= debounce.0.3.out => jogCntrl.keys.yneg
net jog.deb.key-z-pos       <= debounce.0.4.out => jogCntrl.keys.zpos
net jog.deb.key-z-neg       <= debounce.0.5.out => jogCntrl.keys.zneg
net jog.deb.key-a-pos       <= debounce.0.6.out => jogCntrl.keys.apos
net jog.deb.key-a-neg       <= debounce.0.7.out => jogCntrl.keys.aneg


net jog.out.key-x-pos       <= jogCntrl.out.xpos    => halui.axis.x.plus
net jog.out.key-x-neg       <= jogCntrl.out.xneg    => halui.axis.x.minus
net jog.out.key-y-pos       <= jogCntrl.out.ypos    => halui.axis.y.plus
net jog.out.key-y-neg       <= jogCntrl.out.yneg    => halui.axis.y.minus
net jog.out.key-z-pos       <= jogCntrl.out.zpos    => halui.axis.z.plus
net jog.out.key-z-neg       <= jogCntrl.out.zneg    => halui.axis.z.minus
net jog.out.key-a-pos       <= jogCntrl.out.apos    #=> halui.axis.a.plus
net jog.out.key-a-neg       <= jogCntrl.out.aneg    #=> halui.axis.a.minus


net jog.out.key-x-pos       => STM_IO.OUT.26
net jog.out.key-x-neg       => STM_IO.OUT.24
net jog.out.key-y-pos       => STM_IO.OUT.02
net jog.out.key-y-neg       => STM_IO.OUT.42
net jog.out.key-z-pos       => STM_IO.OUT.33
net jog.out.key-z-neg       => STM_IO.OUT.07
net jog.out.key-a-pos       => STM_IO.OUT.05
net jog.out.key-a-neg       => STM_IO.OUT.09


loadrt select8 
addf select8  servo-thread

net jog.lastAxis.data       <= jogCntrl.lastActive => select8.0.sel






#net key-x <= hm2_7i92.0.TsHW.0.0.key-01
#net key-x => hm2_7i92.0.TsHW.0.0.led-01
#net key-x => shw.ena-x.in0
#net ena-x shw.ena-x.out => axis.x.jog-enable














# program start pause resume stop with two buttons
loadrt lut5 names=STM_IO.start.lut,STM_IO.pause.lut,STM_IO.resume.lut
addf STM_IO.start.lut    servo-thread
addf STM_IO.pause.lut    servo-thread
addf STM_IO.resume.lut   servo-thread


setp STM_IO.start.lut.function   0x800      # Start program. Button & is-idle & is-auto have to be true
setp STM_IO.pause.lut.function   0x2000     # pause when running. Button & is-running   & is-auto
setp STM_IO.resume.lut.function  0x2000000  # resume when paused. Button & is-is−paused & is-auto


#inputs for the lut5 
net  STM_IO.start.IN0      <= STM_IO.IN.09              => STM_IO.start.lut.in0  => STM_IO.pause.lut.in0  => STM_IO.resume.lut.in0
net  STM_IO.start.IN1      <= halui.program.is−idle     => STM_IO.start.lut.in1  => STM_IO.pause.lut.in1  => STM_IO.resume.lut.in1
net  STM_IO.start.IN2      <= halui.program.is−running  => STM_IO.start.lut.in2  => STM_IO.pause.lut.in2  => STM_IO.resume.lut.in2
net  STM_IO.start.IN3      <= halui.program.is-auto     => STM_IO.start.lut.in3  => STM_IO.pause.lut.in3  => STM_IO.resume.lut.in3
net  STM_IO.start.IN4      <= halui.program.is−paused   => STM_IO.start.lut.in3  => STM_IO.pause.lut.in4  => STM_IO.resume.lut.in4

#start program when lut1 is true
net  STM_IO.start.OUT      <= STM_IO.start.lut.out
net  STM_IO.start.OUT      => halui.program.run
net  STM_IO.start.OUT      => halui.mode.auto
#pause program when lut2 is true
net  STM_IO.pause.OUT      <= STM_IO.pause.lut.out
net  STM_IO.pause.OUT      => halui.program.pause
#resume program when lut3 is true
net  STM_IO.resume.OUT      <= STM_IO.resume.lut.out
net  STM_IO.resume.OUT      => halui.program.resume 


#stop program when stop is pressed
net  STM_IO.stop      <= STM_IO.IN.01
net  STM_IO.stop      => halui.program.stop


#led start is on during running and paused
net STM_IO.led-start.IN0   <= halui.program.is−running   => STM_IO.led-start.in0
net STM_IO.led-start.IN1   <= halui.program.is−paused    => STM_IO.led-start.in1
net STM_IO.led-start       <= STM_IO.led-start.out
net STM_IO.led-start       => STM_IO.OUT.17

#led stop is on during idle and paused
net STM_IO.led-stop.IN0   <= halui.program.is−paused   => STM_IO.led-stop.in0
net STM_IO.led-stop.IN1   <= halui.program.is−idle    => STM_IO.led-stop.in1
net STM_IO.led-stop       <= STM_IO.led-stop.out
net STM_IO.led-stop       => STM_IO.OUT.16

















